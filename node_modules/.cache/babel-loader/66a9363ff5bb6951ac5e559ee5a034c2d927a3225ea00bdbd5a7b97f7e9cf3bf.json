{"ast":null,"code":"import _slicedToArray from\"/Users/uxay/Documents/shader-training/wavy-images/wavey/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import React,{useRef,Suspense}from\"react\";import*as THREE from\"three\";import{Canvas,extend,useFrame,useLoader}from\"@react-three/fiber\";import{shaderMaterial}from\"@react-three/drei\";import ACS from\"../imgs/acs-banner.png\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";var WaveyShaderMaterial=shaderMaterial(// Uniform\n{uTime:0,uColor:new THREE.Color(0.0,0.0,0.0),uTexture:new THREE.Texture()},// Vertex Shader\n\"\\n      precision mediump float;\\n   \\n      varying vec2 vUv;\\n      varying float vWave;\\n  \\n      uniform float uTime;\\n  \\n      //\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_1971453045(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_1971453045(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_1971453045(vec4 x) {\\n     return mod289_1971453045(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_1971453045(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise3(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D_1971453045 = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g_1971453045 = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g_1971453045;\\n  vec3 i1 = min( g_1971453045.xyz, l.zxy );\\n  vec3 i2 = max( g_1971453045.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D_1971453045.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289_1971453045(i);\\n  vec4 p = permute_1971453045( permute_1971453045( permute_1971453045(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D_1971453045.wyz - D_1971453045.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1_1971453045 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0_1971453045 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1_1971453045.xy,h.z);\\n  vec3 p3 = vec3(a1_1971453045.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt_1971453045(vec4(dot(p0_1971453045,p0_1971453045), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0_1971453045 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0_1971453045,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\n  \\n      void main() {\\n        vUv = uv;\\n  \\n        vec3 pos = position;\\n        float noiseFreq = 1.6;\\n        float noiseAmp = 0.2;\\n        vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\\n        pos.z += snoise3(noisePos) * noiseAmp;\\n        vWave = pos.z;\\n  \\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);  \\n      }\\n    \",// Fragment Shader\n\"\\n      precision mediump float;\\n  \\n      uniform vec3 uColor;\\n      uniform float uTime;\\n      uniform sampler2D uTexture;\\n  \\n      varying vec2 vUv;\\n      varying float vWave;\\n  \\n      void main() {\\n        float wave = vWave * 0.12;\\n        vec3 texture = texture2D(uTexture, vUv + wave).rgb;\\n        gl_FragColor = vec4(texture, 1.0); \\n      }\\n    \");extend({WaveyShaderMaterial:WaveyShaderMaterial});var Wave=function Wave(){var ref=useRef();useFrame(function(_ref){var clock=_ref.clock;return ref.current.uTime=clock.getElapsedTime();});var _useLoader=useLoader(THREE.TextureLoader,[ACS]),_useLoader2=_slicedToArray(_useLoader,1),image=_useLoader2[0];return/*#__PURE__*/_jsxs(\"mesh\",{children:[/*#__PURE__*/_jsx(\"planeBufferGeometry\",{args:[16,9]}),/*#__PURE__*/_jsx(\"waveyShaderMaterial\",{uColor:\"hotpink\",ref:ref,uTexture:image})]});};var PrezzeeCard=function PrezzeeCard(){return/*#__PURE__*/_jsxs(\"div\",{class:\"projectItem\",children:[/*#__PURE__*/_jsx(Canvas,{className:\"wid80\",camera:{fov:28,position:[0,0,12]},children:/*#__PURE__*/_jsx(Suspense,{fallback:null,children:/*#__PURE__*/_jsx(Wave,{})})}),/*#__PURE__*/_jsx(\"div\",{class:\"projectName\",children:/*#__PURE__*/_jsxs(\"h2\",{class:\" text\",children:[/*#__PURE__*/_jsxs(\"span\",{children:[\" \",/*#__PURE__*/_jsx(\"sup\",{children:\"05\"}),\" \"]}),\"Prezzee\"]})})]});};export default PrezzeeCard;","map":{"version":3,"names":["React","useRef","Suspense","THREE","Canvas","extend","useFrame","useLoader","shaderMaterial","ACS","jsx","_jsx","jsxs","_jsxs","WaveyShaderMaterial","uTime","uColor","Color","uTexture","Texture","Wave","ref","_ref","clock","current","getElapsedTime","_useLoader","TextureLoader","_useLoader2","_slicedToArray","image","children","args","PrezzeeCard","class","className","camera","fov","position","fallback"],"sources":["/Users/uxay/Documents/shader-training/wavy-images/wavey/src/components/PrezzeeCard.js"],"sourcesContent":["import React, { useRef, Suspense } from \"react\";\nimport * as THREE from \"three\";\nimport { Canvas, extend, useFrame, useLoader } from \"@react-three/fiber\";\nimport { shaderMaterial } from \"@react-three/drei\";\nimport glsl from \"babel-plugin-glsl/macro\";\nimport ACS from \"../imgs/acs-banner.png\";\n\nconst WaveyShaderMaterial = shaderMaterial (\n    // Uniform\n    {\n      uTime: 0,\n      uColor: new THREE.Color(0.0, 0.0, 0.0),\n      uTexture: new THREE.Texture()\n    },\n    // Vertex Shader\n    glsl`\n      precision mediump float;\n   \n      varying vec2 vUv;\n      varying float vWave;\n  \n      uniform float uTime;\n  \n      #pragma glslify: snoise3 = require(glsl-noise/simplex/3d.glsl);\n  \n      void main() {\n        vUv = uv;\n  \n        vec3 pos = position;\n        float noiseFreq = 1.6;\n        float noiseAmp = 0.2;\n        vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\n        pos.z += snoise3(noisePos) * noiseAmp;\n        vWave = pos.z;\n  \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);  \n      }\n    `,\n    // Fragment Shader\n    glsl`\n      precision mediump float;\n  \n      uniform vec3 uColor;\n      uniform float uTime;\n      uniform sampler2D uTexture;\n  \n      varying vec2 vUv;\n      varying float vWave;\n  \n      void main() {\n        float wave = vWave * 0.12;\n        vec3 texture = texture2D(uTexture, vUv + wave).rgb;\n        gl_FragColor = vec4(texture, 1.0); \n      }\n    `\n  );\n  \n  extend({ WaveyShaderMaterial });\n  \n  const Wave = () => {\n    const ref = useRef();\n    useFrame(({ clock }) => (ref.current.uTime = clock.getElapsedTime()));\n  \n    const [image] = useLoader(THREE.TextureLoader, [\n      ACS\n    ]);\n  \n    return (\n      <mesh>\n        <planeBufferGeometry args={[16, 9]} />\n        <waveyShaderMaterial uColor={\"hotpink\"} ref={ref} uTexture={image} />\n      </mesh>\n    );\n  };\n\nconst PrezzeeCard = () => {\n  return (\n    <div class=\"projectItem\">\n        <Canvas className='wid80' camera={{ fov: 28, position: [0, 0, 12] }}>\n          <Suspense fallback={null}>\n            <Wave />\n          </Suspense>\n        </Canvas>\n        <div class=\"projectName\">\n            <h2 class=\" text\">\n                <span> <sup>05</sup> </span>\n                Prezzee\n            </h2>\n        </div>\n    </div>\n  );\n};\n\nexport default PrezzeeCard;"],"mappings":"6IAAA,MAAO,CAAAA,KAAK,EAAIC,MAAM,CAAEC,QAAQ,KAAQ,OAAO,CAC/C,MAAO,GAAK,CAAAC,KAAK,KAAM,OAAO,CAC9B,OAASC,MAAM,CAAEC,MAAM,CAAEC,QAAQ,CAAEC,SAAS,KAAQ,oBAAoB,CACxE,OAASC,cAAc,KAAQ,mBAAmB,CAElD,MAAO,CAAAC,GAAG,KAAM,wBAAwB,CAAC,OAAAC,GAAA,IAAAC,IAAA,gCAAAC,IAAA,IAAAC,KAAA,yBAEzC,GAAM,CAAAC,mBAAmB,CAAGN,cAAc,CACtC;AACA,CACEO,KAAK,CAAE,CAAC,CACRC,MAAM,CAAE,GAAI,CAAAb,KAAK,CAACc,KAAK,CAAC,GAAG,CAAE,GAAG,CAAE,GAAG,CAAC,CACtCC,QAAQ,CAAE,GAAI,CAAAf,KAAK,CAACgB,OAAO,CAAC,CAC9B,CAAC,CACD;AAAA,4qHAwBA;AAAA,gXAiBF,CAAC,CAEDd,MAAM,CAAC,CAAES,mBAAmB,CAAnBA,mBAAoB,CAAC,CAAC,CAE/B,GAAM,CAAAM,IAAI,CAAG,QAAP,CAAAA,IAAIA,CAAA,CAAS,CACjB,GAAM,CAAAC,GAAG,CAAGpB,MAAM,CAAC,CAAC,CACpBK,QAAQ,CAAC,SAAAgB,IAAA,KAAG,CAAAC,KAAK,CAAAD,IAAA,CAALC,KAAK,OAAQ,CAAAF,GAAG,CAACG,OAAO,CAACT,KAAK,CAAGQ,KAAK,CAACE,cAAc,CAAC,CAAC,EAAC,CAAC,CAErE,IAAAC,UAAA,CAAgBnB,SAAS,CAACJ,KAAK,CAACwB,aAAa,CAAE,CAC7ClB,GAAG,CACJ,CAAC,CAAAmB,WAAA,CAAAC,cAAA,CAAAH,UAAA,IAFKI,KAAK,CAAAF,WAAA,IAIZ,mBACEf,KAAA,SAAAkB,QAAA,eACEpB,IAAA,wBAAqBqB,IAAI,CAAE,CAAC,EAAE,CAAE,CAAC,CAAE,CAAE,CAAC,cACtCrB,IAAA,wBAAqBK,MAAM,CAAE,SAAU,CAACK,GAAG,CAAEA,GAAI,CAACH,QAAQ,CAAEY,KAAM,CAAE,CAAC,EACjE,CAAC,CAEX,CAAC,CAEH,GAAM,CAAAG,WAAW,CAAG,QAAd,CAAAA,WAAWA,CAAA,CAAS,CACxB,mBACEpB,KAAA,QAAKqB,KAAK,CAAC,aAAa,CAAAH,QAAA,eACpBpB,IAAA,CAACP,MAAM,EAAC+B,SAAS,CAAC,OAAO,CAACC,MAAM,CAAE,CAAEC,GAAG,CAAE,EAAE,CAAEC,QAAQ,CAAE,CAAC,CAAC,CAAE,CAAC,CAAE,EAAE,CAAE,CAAE,CAAAP,QAAA,cAClEpB,IAAA,CAACT,QAAQ,EAACqC,QAAQ,CAAE,IAAK,CAAAR,QAAA,cACvBpB,IAAA,CAACS,IAAI,GAAE,CAAC,CACA,CAAC,CACL,CAAC,cACTT,IAAA,QAAKuB,KAAK,CAAC,aAAa,CAAAH,QAAA,cACpBlB,KAAA,OAAIqB,KAAK,CAAC,OAAO,CAAAH,QAAA,eACblB,KAAA,SAAAkB,QAAA,EAAM,GAAC,cAAApB,IAAA,QAAAoB,QAAA,CAAK,IAAE,CAAK,CAAC,IAAC,EAAM,CAAC,UAEhC,EAAI,CAAC,CACJ,CAAC,EACL,CAAC,CAEV,CAAC,CAED,cAAe,CAAAE,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}